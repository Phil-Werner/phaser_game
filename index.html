<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Phaser 3 Game </title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.19.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    let config = {
        type: Phaser.AUTO,
        width: 1190,
        height: 620,
        physics: {
            default: 'arcade',
            arcade: {

                setBounds: {
                    width: 3000,
                    height: 600
                },
                gravity: { y: 0 },
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    let hasClickedOnce = false;
    let player;
    let objectIsSelected = false;
    let playerMoving = false;
    let tileSelected = null;
    let tileIsSelected = false;
    let availableMoves;
    let starGroup;
    let destination;
    let testCoor;
    let playersTurn = true;
    let MAXHEIGHT = 28;
    let MAXWIDTH = 26;
    let selfScene;
    let enemyArray;
    let enemyIndex;
    let heroArray;
    let heroIndex;
    let awaitingEnemySelection = false;
    let arrayOfNearbyEnemies;
    let enemyDying = false;
    let enemyBDying = false;
    let enemyCDying = false;
    let grid =     [[3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];

    let cameFromGrid;
    let heroCoor = [2, 12];
    let heroBCoor = [3, 12];
    let enemyCoor = [20, 1];
    let enemyBCoor = [20, 2];
    let enemyCCoor = [20, 3];

    grid[heroCoor[1]][heroCoor[0]] = 1;
    grid[heroBCoor[1]][heroBCoor[0]] = 1;
    grid[enemyCoor[1]][enemyCoor[0]] = 2;
    grid[enemyBCoor[1]][enemyBCoor[0]] = 2;
    grid[enemyCCoor[1]][enemyCCoor[0]] = 2;

    let numLiveEnemies = 3;
    let game = new Phaser.Game(config);

    function preload ()
    {

        this.load.image('rightArrow', 'assets/right.jpg');

        this.load.image('sky', 'assets/sky.png');
        this.load.image('ground', 'assets/platform.png');
        this.load.image('star', 'assets/star.png');
        this.load.image('bomb', 'assets/bomb.png');
        this.load.spritesheet('dude', 'assets/dude.png', { frameWidth: 32, frameHeight: 48 });
        this.load.image('spark', 'assets/blue.png');
        this.load.image('levelOne', 'assets/grid5.png');

        this.load.image('idle1', 'assets/idle1.png');
        this.load.image('idle2', 'assets/idle2.png');
        this.load.image('idle3', 'assets/idle3.png');
        this.load.image('idle4', 'assets/idle4.png');
        this.load.image('idle5', 'assets/idle5.png');
        this.load.image('idle6', 'assets/idle6.png');
        this.load.image('idle7', 'assets/idle7.png');
        this.load.image('idle8', 'assets/idle8.png');
        this.load.image('idle9', 'assets/idle9.png');
        this.load.image('idle10', 'assets/idle10.png');

        this.load.image('run1', 'assets/run1.png');
        this.load.image('run2', 'assets/run2.png');
        this.load.image('run3', 'assets/run3.png');
        this.load.image('run4', 'assets/run4.png');
        this.load.image('run5', 'assets/run5.png');
        this.load.image('run6', 'assets/run6.png');
        this.load.image('run7', 'assets/run7.png');
        this.load.image('run8', 'assets/run8.png');
        this.load.image('run9', 'assets/run9.png');
        this.load.image('run10', 'assets/run10.png');

        this.load.image('runl1', 'assets/runl1.png');
        this.load.image('runl2', 'assets/runl2.png');
        this.load.image('runl3', 'assets/runl3.png');
        this.load.image('runl4', 'assets/runl4.png');
        this.load.image('runl5', 'assets/runl5.png');
        this.load.image('runl6', 'assets/runl6.png');
        this.load.image('runl7', 'assets/runl7.png');
        this.load.image('runl8', 'assets/runl8.png');
        this.load.image('runl9', 'assets/runl9.png');
        this.load.image('runl10', 'assets/runl10.png');

        this.load.image('barbIdle1', 'assets/barbIdleLeft1.png');
        this.load.image('barbIdle2', 'assets/barbIdleLeft2.png');
        this.load.image('barbIdle3', 'assets/barbIdleLeft3.png');
        this.load.image('barbIdle4', 'assets/barbIdleLeft4.png');
        this.load.image('barbIdle5', 'assets/barbIdleLeft5.png');
        this.load.image('barbIdle6', 'assets/barbIdleLeft6.png');

        this.load.image('barbWalkLeft1', 'assets/barbWalkLeft1.png');
        this.load.image('barbWalkLeft2', 'assets/barbWalkLeft2.png');
        this.load.image('barbWalkLeft3', 'assets/barbWalkLeft3.png');
        this.load.image('barbWalkLeft4', 'assets/barbWalkLeft4.png');
        this.load.image('barbWalkLeft5', 'assets/barbWalkLeft5.png');
        this.load.image('barbWalkLeft6', 'assets/barbWalkLeft6.png');
        this.load.image('barbWalkLeft7', 'assets/barbWalkLeft7.png');
        this.load.image('barbWalkLeft8', 'assets/barbWalkLeft8.png');
        this.load.image('barbWalkLeft9', 'assets/barbWalkLeft9.png');
        this.load.image('barbWalkLeft10', 'assets/barbWalkLeft10.png');
        this.load.image('barbWalkLeft11', 'assets/barbWalkLeft11.png');
        this.load.image('barbWalkLeft12', 'assets/barbWalkLeft12.png');
        this.load.image('barbWalkLeft13', 'assets/barbWalkLeft13.png');
        this.load.image('barbWalkLeft14', 'assets/barbWalkLeft14.png');

        this.load.image('barbWalk1', 'assets/barbWalk1.png');
        this.load.image('barbWalk2', 'assets/barbWalk2.png');
        this.load.image('barbWalk3', 'assets/barbWalk3.png');
        this.load.image('barbWalk4', 'assets/barbWalk4.png');
        this.load.image('barbWalk5', 'assets/barbWalk5.png');
        this.load.image('barbWalk6', 'assets/barbWalk6.png');
        this.load.image('barbWalk7', 'assets/barbWalk7.png');
        this.load.image('barbWalk8', 'assets/barbWalk8.png');
        this.load.image('barbWalk9', 'assets/barbWalk9.png');
        this.load.image('barbWalk10', 'assets/bwten.png');
        this.load.image('barbWalk11', 'assets/barbWalk11.png');
        this.load.image('barbWalk12', 'assets/barbWalk12.png');
        this.load.image('barbWalk13', 'assets/barbWalk13.png');
        this.load.image('barbWalk14', 'assets/barbWalk14.png');

        this.load.image('heroAttack1', 'assets/heroAttack1.png');
        this.load.image('heroAttack2', 'assets/heroAttack2.png');
        this.load.image('heroAttack3', 'assets/heroAttack3.png');
        this.load.image('heroAttack4', 'assets/heroAttack4.png');
        this.load.image('heroAttack5', 'assets/heroAttack5.png');
        this.load.image('heroAttack6', 'assets/heroAttack6.png');
        this.load.image('heroAttack7', 'assets/heroAttack7.png');
        this.load.image('heroAttack8', 'assets/heroAttack8.png');
        this.load.image('heroAttack9', 'assets/heroAttack9.png');
        this.load.image('heroAttack10', 'assets/heroAttack10.png');

        this.load.image('heroAttackLeft1', 'assets/heroAttackLeft1.png');
        this.load.image('heroAttackLeft2', 'assets/heroAttackLeft2.png');
        this.load.image('heroAttackLeft3', 'assets/heroAttackLeft3.png');
        this.load.image('heroAttackLeft4', 'assets/heroAttackLeft4.png');
        this.load.image('heroAttackLeft5', 'assets/heroAttackLeft5.png');
        this.load.image('heroAttackLeft6', 'assets/heroAttackLeft6.png');
        this.load.image('heroAttackLeft7', 'assets/heroAttackLeft7.png');
        this.load.image('heroAttackLeft8', 'assets/heroAttackLeft8.png');
        this.load.image('heroAttackLeft9', 'assets/heroAttackLeft9.png');
        this.load.image('heroAttackLeft10', 'assets/heroAttackLeft10.png');

        this.load.image('barbAttack1', 'assets/barbAttack1.png');
        this.load.image('barbAttack2', 'assets/barbAttack2.png');
        this.load.image('barbAttack3', 'assets/barbAttack3.png');
        this.load.image('barbAttack4', 'assets/barbAttack4.png');
        this.load.image('barbAttack5', 'assets/barbAttack5.png');
        this.load.image('barbAttack6', 'assets/barbAttack6.png');
        this.load.image('barbAttack7', 'assets/barbAttack7.png');
        this.load.image('barbAttack8', 'assets/barbAttack8.png');

        this.load.image('barbAttackLeft1', 'assets/barbAttackLeft1.png');
        this.load.image('barbAttackLeft2', 'assets/barbAttackLeft2.png');
        this.load.image('barbAttackLeft3', 'assets/barbAttackLeft3.png');
        this.load.image('barbAttackLeft4', 'assets/barbAttackLeft4.png');
        this.load.image('barbAttackLeft5', 'assets/barbAttackLeft5.png');
        this.load.image('barbAttackLeft6', 'assets/barbAttackLeft6.png');
        this.load.image('barbAttackLeft7', 'assets/barbAttackLeft7.png');
        this.load.image('barbAttackLeft8', 'assets/barbAttackLeft8.png');

        this.load.image('barbDead1', 'assets/dead1.png');
        this.load.image('barbDead2', 'assets/dead2.png');
        this.load.image('barbDead3', 'assets/dead3.png');
        this.load.image('barbDead4', 'assets/dead4.png');
        this.load.image('barbDead5', 'assets/dead5.png');
        this.load.image('barbDead6', 'assets/dead6.png');
    }

    function create ()
    {
        starGroup = this.add.group();
        this.add.image(596, 316, 'levelOne');

        let rArrow = this.add.sprite(700, 400, 'rightArrow').setInteractive();
        rArrow.setScale(0.3);

        rArrow.on('pointerdown', function (pointer) {

            console.log("Right arrow pressed!!");

            });

        let startingCoordinates = calculateCoordinates([heroCoor[0], heroCoor[1]]);
        let heroBStartCoor = calculateCoordinates([heroBCoor[0], heroBCoor[1]]);
        let enemyStarCoor = calculateCoordinates([enemyCoor[0], enemyCoor[1]]);
        let enemyBStartCoor = calculateCoordinates([enemyBCoor[0], enemyBCoor[1]]);
        let enemyCStartCoor = calculateCoordinates([enemyCCoor[0], enemyCCoor[1]]);

        this.input.on('gameobjectup', function (pointer, gameObject)
        {
            gameObject.emit('clicked', gameObject);
        }, this);

        this.anims.create({
            key: 'left',
             frames: [
                { key: 'runl1' },
                { key: 'runl2' },
                { key: 'runl3' },
                { key: 'runl4' },
                { key: 'runl5' },
                { key: 'runl6' },
                { key: 'runl7' },
                { key: 'runl8' },
                { key: 'runl9' },
                { key: 'runl10', duration: 50 }
            ],
            frameRate: 10,
            repeat: -1
        });

        this.anims.create({
            key: 'turn',
            frames: [ { key: 'dude', frame: 4 } ],
            frameRate: 20
        });

        this.anims.create({
            key: 'right',
            frames: [
                { key: 'run1' },
                { key: 'run2' },
                { key: 'run3' },
                { key: 'run4' },
                { key: 'run5' },
                { key: 'run6' },
                { key: 'run7' },
                { key: 'run8' },
                { key: 'run9' },
                { key: 'run10', duration: 50 }
            ],
            frameRate: 16,
            repeat: -1
        });

        this.anims.create({
            key: 'snooze',
            frames: [
                { key: 'idle1' },
                { key: 'idle2' },
                { key: 'idle3' },
                { key: 'idle4' },
                { key: 'idle5' },
                { key: 'idle6' },
                { key: 'idle7' },
                { key: 'idle8' },
                { key: 'idle9' },
                { key: 'idle10', duration: 50 }
            ],
            frameRate: 8,
            repeat: -1
        });

        this.anims.create({
            key: 'barbSnooze',
            frames: [
                { key: 'barbIdle1' },
                { key: 'barbIdle2' },
                { key: 'barbIdle3' },
                { key: 'barbIdle4' },
                { key: 'barbIdle5' },
                { key: 'barbIdle6', duration: 50 }
            ],
            frameRate: 8,
            repeat: -1
        });

        this.anims.create({
            key: 'barbWalkLeft',
            frames: [
                { key: 'barbWalkLeft1' },
                { key: 'barbWalkLeft2' },
                { key: 'barbWalkLeft3' },
                { key: 'barbWalkLeft4' },
                { key: 'barbWalkLeft5' },
                { key: 'barbWalkLeft6' },
                { key: 'barbWalkLeft7' },
                { key: 'barbWalkLeft8' },
                { key: 'barbWalkLeft9' },
                { key: 'barbWalkLeft10' },
                { key: 'barbWalkLeft11' },
                { key: 'barbWalkLeft12' },
                { key: 'barbWalkLeft13' },
                { key: 'barbWalkLeft14', duration: 50 }
            ],
            frameRate: 16,
            repeat: -1
        });

        this.anims.create({
            key: 'barbWalk',
            frames: [
                { key: 'barbWalk1' },
                { key: 'barbWalk2' },
                { key: 'barbWalk3' },
                { key: 'barbWalk4' },
                { key: 'barbWalk5' },
                { key: 'barbWalk6' },
                { key: 'barbWalk7' },
                { key: 'barbWalk8' },
                { key: 'barbWalk9' },
                { key: 'barbWalk10' },
                { key: 'barbWalk11' },
                { key: 'barbWalk12' },
                { key: 'barbWalk13' },
                { key: 'barbWalk14', duration: 50 }
            ],
            frameRate: 16,
            repeat: -1
        });

        this.anims.create({
            key: 'barbAttack',
            frames: [
                { key: 'barbAttack1' },
                { key: 'barbAttack2' },
                { key: 'barbAttack3' },
                { key: 'barbAttack4' },
                { key: 'barbAttack5' },
                { key: 'barbAttack6' },
                { key: 'barbAttack7' },
                { key: 'barbAttack8', duration: 50 }
            ],
            frameRate: 16,
            repeat: 0,
        });

        this.anims.create({
            key: 'barbAttackLeft',
            frames: [
                { key: 'barbAttackLeft1' },
                { key: 'barbAttackLeft2' },
                { key: 'barbAttackLeft3' },
                { key: 'barbAttackLeft4' },
                { key: 'barbAttackLeft5' },
                { key: 'barbAttackLeft6' },
                { key: 'barbAttackLeft7' },
                { key: 'barbAttackLeft8', duration: 50 }
            ],
            frameRate: 16,
            repeat: 0,
        });

        this.anims.create({
            key: 'heroAttack',
            frames: [
                { key: 'heroAttack1' },
                { key: 'heroAttack2' },
                { key: 'heroAttack3' },
                { key: 'heroAttack4' },
                { key: 'heroAttack5' },
                { key: 'heroAttack6' },
                { key: 'heroAttack7' },
                { key: 'heroAttack8' },
                { key: 'heroAttack9' },
                { key: 'heroAttack10', duration: 50 }
            ],
            frameRate: 16,
            repeat: 0,
        });



        this.anims.create({
            key: 'heroAttackLeft',
            frames: [
                { key: 'heroAttackLeft1' },
                { key: 'heroAttackLeft2' },
                { key: 'heroAttackLeft3' },
                { key: 'heroAttackLeft4' },
                { key: 'heroAttackLeft5' },
                { key: 'heroAttackLeft6' },
                { key: 'heroAttackLeft7' },
                { key: 'heroAttackLeft8' },
                { key: 'heroAttackLeft9' },
                { key: 'heroAttackLeft10', duration: 50 }
            ],
            frameRate: 16,
            repeat: 0,
        });

        this.anims.create({
            key: 'barbDead',
            frames: [
                { key: 'barbDead1' },
                { key: 'barbDead2' },
                { key: 'barbDead3' },
                { key: 'barbDead4' },
                { key: 'barbDead5' },
                { key: 'barbDead6', duration: 50 }
            ],
            frameRate: 16,
            repeat: 0,
            onComplete: enemyFinishedDying
        });


        player = this.add.sprite(startingCoordinates[0] + 6, startingCoordinates[1] - 14, 'idle1').play('snooze');
        player.setScale(0.11);
        player.depth = 2;
        player.coor = [heroCoor[0], heroCoor[1]];
        player.hasMovedThisTurn = false;
        //player.setScrollFactor(0);

        heroB = this.physics.add.sprite(heroBStartCoor[0] + 6, heroBStartCoor[1] - 14, 'idle1').play('snooze');
        heroB.setScale(0.11);
        heroB.depth = 2;
        heroB.setTint(0xff0000);
        heroB.coor = [heroBCoor[0], heroBCoor[1]];
        heroB.hasMovedThisTurn = false;

        enemy = this.physics.add.sprite(enemyStarCoor[0] - 2, enemyStarCoor[1] - 14, 'barbIdle1').play('barbSnooze');
        enemy.setScale(0.3);
        enemy.depth = 2;
        enemy.coor = [enemyCoor[0], enemyCoor[1]];
        enemy.attackingThisTurn = false;
        enemy.hitPoints = 3;
        enemy.isDead = false;
        enemy.indexOfHeroToBeAttacked = 0;

        enemyB = this.physics.add.sprite(enemyBStartCoor[0] - 2, enemyBStartCoor[1] - 14, 'barbIdle1').play('barbSnooze');
        //enemyB.setTint(0xff0000);
        enemyB.setScale(0.3);
        enemyB.coor = [enemyBCoor[0], enemyBCoor[1]];
        enemyB.attackingThisTurn = false;
        enemyB.hitPoints = 3;
        enemyB.isDead = false;
        enemyB.indexOfHeroToBeAttacked = 0;

        enemyC = this.physics.add.sprite(enemyCStartCoor[0] - 2, enemyCStartCoor[1] - 14, 'barbIdle1').play('barbSnooze');
        enemyC.setTint(0xff0000);
        enemyC.setScale(0.3);
        enemyC.coor = [enemyCCoor[0], enemyCCoor[1]];
        enemyC.hitPoints = 3;
        enemyC.attackingThisTurn = false;
        enemyC.isDead = false;
        enemyC.indexOfHeroToBeAttacked = 0;

        enemyArray = [enemy, enemyB, enemyC];
        enemyIndex = 0;

        heroArray = [player, heroB];
        heroIndex = 0;

        //let heroSelectedHex;

        this.input.on('pointerdown', function (pointer)
        {
            if (hasClickedOnce) {
                this.cameras.main.scrollX = 0;
            }
            if (!hasClickedOnce) {
                this.cameras.main.scrollX = 200;
                hasClickedOnce = true;

            }

        }, this);
/*
            let hexClicked = determineWhichHex(pointer.x, pointer.y);

            if (playersTurn) {

              //  enemyArray[0].on('animationcomplete', stupid);

                if (!awaitingEnemySelection) {

                    enemyIndex = 0;

                    console.log("tileIsSelected = ", tileIsSelected);

                    if (tileIsSelected === false) {

                        if (tileCanBeSelected(hexClicked) && !playerMoving) {

                            tileSelected = hexClicked;
                            heroIndex = determineWhichHero(tileSelected);

                            console.log("heroIndex = ", heroIndex);

                            if (heroArray[heroIndex].hasMovedThisTurn === false) {


                                tileIsSelected = true;

                                heroArray[heroIndex].hasMovedThisTurn = true;
                                let coordinates;
                                availableMoves = generateAvailableMoves(hexClicked, 7);

                                console.log("availalbeMoves =", availableMoves);

                                for (let i = 0; i < availableMoves.length; i++) {

                                    coordinates = calculateCoordinates(availableMoves[i]);
                                    starGroup.create(coordinates[0], coordinates[1], 'star');
                                }
                            } else {

                            }
                        }
                    } else {        //tile is selected

                        if (arrayIncludesCoordinates(availableMoves, hexClicked)) {

                            tileIsSelected = false;

                            heroIndex = determineWhichHero(tileSelected);

                            console.log("heroIndex = ", heroIndex);

                           // starGroup.getChildren().forEach(function(elm) {
                            //   if (elm.active) {
                            //        elm.destroy();
                            //    }
                             //  elm.clear(false, true);
                           // });

                            starGroup.clear(true, true);

                            console.log("Stargroup = ", starGroup);

                            playerMoving = true;
                            let heroCoorCoor = calculateCoordinates(heroArray[heroIndex].coor);
                            let hexClickedCoor = calculateCoordinates(hexClicked);
                            let hexPath = determinePath(hexClicked, heroArray[heroIndex].coor);

                            selfScene = this;

                            let currentCoor = calculateCoordinates(hexPath[0]);
                            let playerTween;
                            let currentIndex = 0;

                            if (heroArray[heroIndex].x > currentCoor[0]) {
                                heroArray[heroIndex].anims.play('left');
                            } else {
                                heroArray[heroIndex].anims.play('right');
                            }

                            grid[hexClicked[1]][hexClicked[0]] = 1;
                            grid[heroArray[heroIndex].coor[1]][heroArray[heroIndex].coor[0]] = 0;
                            heroCoor = hexClicked;
                            heroArray[heroIndex].coor = hexClicked;

                            moveToNextHex(hexPath[currentIndex]);

                            //let adjacentHeroCoorsB = determineAdjacentHeroes(enemyBCoor);
                            //let adjacentHeroCoorsC = determineAdjacentHeroes(enemyCCoor);

                            // console.log("Adj hero coors B = ", adjacentHeroCoorsB);
                            // console.log("Adj hero coors C = ", adjacentHeroCoorsC);

                            function moveToNextHex(nextHex) {

                                currentCoor = calculateCoordinates(hexPath[currentIndex]);

                                playerTween = selfScene.tweens.add({
                                    targets: heroArray[heroIndex],
                                    x: currentCoor[0] + 6,
                                    y: currentCoor[1] - 14,
                                    duration: 400,
                                    onComplete: function() {

                                        currentIndex++;

                                        if (currentIndex < hexPath.length) {
                                            if (heroArray[heroIndex].x > calculateCoordinates(hexPath[currentIndex])[0]) {

                                                heroArray[heroIndex].anims.play('left');
                                            } else {
                                                heroArray[heroIndex].anims.play('right');
                                            }

                                            moveToNextHex(hexPath[currentIndex]);

                                        } else {  //moved to last hex in path

                                            heroArray[heroIndex].anims.play('snooze');
                                            tileIsSelected = false;
                                            let enemyIndex = 0;
                                            arrayOfNearbyEnemies = determineAdjacentEnemies(heroArray[heroIndex].coor);
                                            console.log("array of adj enemies = ", arrayOfNearbyEnemies);
                                            playerMoving = false;

                                            if (arrayOfNearbyEnemies.length === 0) {



                                                if (!anyHeroesCanStillMove()) {

                                                    playersTurn = false;


                                                    for (let i = 0; i < heroArray.length; i++) {

                                                        heroArray[i].hasMovedThisTurn = false;
                                                    }


                                                    console.log("Calling do enemy moves from input");
                                                    doEnemyMoves();

                                                } else {


                                                }


                                            } else {  //There are adjacent enemies

                                                awaitingEnemySelection = true;
                                            }
                                        }
                                    }
                                });
                            }

                        } else {  //here we did not click on a star, but might have clicked on adjacent enemy


                            console.log("AAAAAAAAAAA");

                            arrayOfNearbyEnemies = determineAdjacentEnemies(heroArray[heroIndex].coor);

                            console.log("Array of nearby enemies = ", arrayOfNearbyEnemies);

                            if (arrayIncludesCoordinates(arrayOfNearbyEnemies, hexClicked)) {
                               // starGroup.getChildren().forEach(function(elm) {
                                  //  if (elm.active) {
                                //        elm.destroy();
                              //      }
                                    //elm.clear(false, true);
                            //    });

                                starGroup.clear(true, true);

                                tileIsSelected = false;

                                console.log("Made it here");

                                heroAttackEnemy(heroIndex, hexClicked);
                            }
                        }
                    }

                } else {   //here we are waiting for player to click on an adjacent enemy

                    if (arrayIncludesCoordinates(arrayOfNearbyEnemies, hexClicked)) {

                        //console.log("!!!!!!!");
                        playersTurn = false;
                        heroAttackEnemy(heroIndex, hexClicked);
                    } else {
                        //console.log("OHOHOHOHO");
                    }

                }
            }

            console.log("spaz", pointer.x, pointer.y);

        }, this);
*/
    }

    function update ()  {
    }

    function anyHeroesCanStillMove() {

        let output = false;

        for (let i = 0; i < heroArray.length; i++) {
            if (heroArray[i].hasMovedThisTurn === false) {
                output = true;
            }
        }

        return output;

    }

    function determineWhichHero(hex) {

        let output;

       // console.log("we gonna do it all night long");

        for (let i = 0; i < heroArray.length; i++) {

            console.log("heroArray[i].coor = ", heroArray[i].coor);
            console.log("hex = ", hex);

            if (arrayIncludesCoordinates([heroArray[i].coor], hex)) {
                output = i;
                break;
            }
        }

        return output;

    }

    function determineWhichEnemy(hex) {

        let output;

       // console.log("we gonna do it all night long");

        for (let i = 0; i < enemyArray.length; i++) {

           // console.log("heroArray[i].coor = ", heroArray[i].coor);
           // console.log("hex = ", hex);

            if (arrayIncludesCoordinates([enemyArray[i].coor], hex)) {
                output = i;
                break;
            }
        }

        return output;

    }

    function heroAttackEnemy(heroAttackingIndex, enemyHex) {

        let enemySprite;

       // console.log("enemy.coor = ", enemy.coor, "enemyHex = ", enemyHex);

        if (arrayIncludesCoordinates([enemy.coor], enemyHex)) {
            enemySprite = enemy;
            enemy.hitPoints--;
            if (enemy.hitPoints === 0 && enemyDying === false) {
                enemyDying = true;
            }
        }
        if (arrayIncludesCoordinates([enemyB.coor], enemyHex)) {
            enemyB.hitPoints--;
            if (enemyB.hitPoints === 0 && enemyBDying === false) {
                enemyBDying = true;
            }
            enemySprite = enemyB;
        }
        if (arrayIncludesCoordinates([enemyC.coor], enemyHex)) {
            enemyC.hitPoints--;
            if (enemyC.hitPoints === 0 && enemyCDying === false) {
                enemyCDying = true;
            }
            enemySprite = enemyC;
        }

        //enemySprite.hitPoints--;

        console.log("heroAttackingIndex = ", heroAttackingIndex);

        if (heroArray[heroAttackingIndex].x > enemySprite.x) {
            heroArray[heroAttackingIndex].anims.play('heroAttackLeft');
        } else {
            heroArray[heroAttackingIndex].anims.play('heroAttack');
        }

        //console.log("enemy Sprite.coor = ", enemySprite.coor);

        heroArray[heroAttackingIndex].once('animationcomplete', heroAttackComplete);

    }

    function heroAttackComplete() {


        console.log("heroattack complete function has begun. Enemey index = ", enemyIndex);

        heroArray[heroIndex].anims.play('snooze');
        awaitingEnemySelection = false;

        if (!anyHeroesCanStillMove()) {

            for (let i = 0; i < heroArray.length; i++) {
                heroArray[i].hasMovedThisTurn = false;
            }

            console.log("Calling doenemymovews from heroattackcomplete");

            doEnemyMoves();
        } else {
            playersTurn = true;
        }
    }

    function attackComplete() {
        console.log("attackComplete just called");
        enemyArray[enemyIndex].anims.play('barbSnooze');
        enemyArray[enemyIndex].attackingThisTurn = false;

                   console.log("In attackComplete function.  EnemyIndex = ", enemyIndex);
            console.log("enemyArray.length - 1 = ", enemyArray.length - 1);

        if (enemyIndex === enemyArray.length - 1) {

          //  console.log("enemyIndex = ", enemyIndex);
          //  console.log("enemyArray.length - 1 = ", enemyArray.length - 1);
            playersTurn = true;
        }

        console.log("Calling doEnemymoves from attackComplete function");

        enemyIndex++;
        doEnemyMoves();
    }

    function clickFunc(player)
    {
       // player.off('clicked', clickFunc);
      //  console.log("Boom!");
        console.log("clickfunc", player.x, player.y);
        //console.log(player);

       // playerSelected = [player, player.x, player.y];
       // objectIsSelected = true;
    }

    function determineWhichHex(pointx, pointy) {

          var hexagonWidth = 54;
          var hexagonHeight = 58;
          var sectorWidth = hexagonWidth;
          var sectorHeight = hexagonHeight/4*3;
          var gradient = (hexagonHeight/4)/(hexagonWidth/2);
          var candidateX = Math.floor((pointx)/sectorWidth);
          var candidateY = Math.floor((pointy)/sectorHeight);
          var deltaX = (pointx)%sectorWidth;
          var deltaY = (pointy)%sectorHeight;
          if(candidateY%2==0){
               if(deltaY<((hexagonHeight/4)-deltaX*gradient)){
                    candidateX--;
                    candidateY--;
               }
               if(deltaY<((-hexagonHeight/4)+deltaX*gradient)){
                    candidateY--;
               }
          }
          else{
               if(deltaX>=hexagonWidth/2){
                    if(deltaY<(hexagonHeight/2-deltaX*gradient)){
                         candidateY--;
                    }
               }
               else{
                    if(deltaY<deltaX*gradient){
                         candidateY--;
                    }
                    else{
                         candidateX--;
                    }
               }
          }

        console.log("candidateX = ", candidateX);
        console.log("candidateY = ", candidateY);

        return [candidateX, candidateY];

    }

    function determinePath(hex, guyCoor) {

        let output = [];
        let currentHex = cameFromGrid[hex[1]][hex[0]];

        for (let i = 0; i < 1000; i++) {

            if (arrayIncludesCoordinates(guyCoor, currentHex)) {
                //console.log("WWWwwwwwWWWWWWWWWWWWWOOOOOOOAAAAHHH");
                break;
            }
            output.push(currentHex);
            currentHex = cameFromGrid[currentHex[1]][currentHex[0]];
        }

        output.pop();
        output.reverse();
        output.push(hex);

        return output;
    }



    function tileCanBeSelected(hex) {

        let output = false;

        if (grid[hex[1]][hex[0]] === 1) {

        //    console.log("You're the man now Dog");
            output = true;
        }

        return output;
    }

    function calculateCoordinates(hex) {

        let x;
        let y = (hex[1] * 58 * 3/4) + 27;

        if (hex[1] % 2 === 0) {
            x = (hex[0] * 54) + 27;
        }

        else {
            x = (hex[0] * 54) + 54;
        }

        return [x, y];

    }

    function arrayIncludesCoordinates(array, coordinates) {

        output = false;

        for (let i = 0; i < array.length; i++) {
            if (array[i][0] === coordinates[0]) {
                if (array[i][1] === coordinates[1]) {
                    output = true;
                }
            }
        }

        return output;
    }

    function determineHeroesInRange(pos, range) {

        let output = [];
        let frontier = [];
        let visited = [pos];
        let coor;
        //let depth = 0;
        let keepPushing = true;
        //let subRange = range;
       // let elementsUntilDepthIncrease = 0;
       // let nextElementsUntilDepthIncrease = 0;
       // let depth = 0;
       // let temp;


        //console.log("POS = ", pos);
        //console.log(pos[0] % 2);

        //check if we're starting on an even row
        if (pos[1] % 2 === 0) {

            // up left
            frontier.push([pos[0] - 1, pos[1] - 1]);
            visited.push([pos[0] - 1, pos[1] - 1]);

            // left
            frontier.push([pos[0] - 1, pos[1]]);
            visited.push([pos[0] - 1, pos[1]]);

            // down left
            frontier.push([pos[0] - 1, pos[1] + 1]);
            visited.push([pos[0] - 1, pos[1] + 1]);

            // down right
            frontier.push([pos[0], pos[1] + 1]);
            visited.push([pos[0], pos[1] + 1]);

            // right
            frontier.push([pos[0] + 1, pos[1]]);
            visited.push([pos[0] + 1, pos[1]]);

            // up right
            frontier.push([pos[0], pos[1] - 1]);
            visited.push([pos[0], pos[1] - 1]);

        // odd rows
        } else {

           // console.log("BOOOOOOOOM");

            //up left
            frontier.push([pos[0], pos[1] - 1]);
            visited.push([pos[0], pos[1] - 1]);

            // left
            frontier.push([pos[0] - 1, pos[1]]);
            visited.push([pos[0] - 1, pos[1]]);

            // down left
            frontier.push([pos[0], pos[1] + 1]);
            visited.push([pos[0], pos[1] + 1]);

            // down right
            frontier.push([pos[0] + 1, pos[1] + 1]);
            visited.push([pos[0] + 1, pos[1] + 1]);

            // right
            frontier.push([pos[0] + 1, pos[1]]);
            visited.push([pos[0] + 1, pos[1]]);

            // up right
            frontier.push([pos[0] + 1, pos[1] - 1]);
            visited.push([pos[0] + 1, pos[1] - 1]);
        }

        while (frontier.length !== 0) {

            coor = frontier.pop();
           // depth--;

            keepPushing = true;

            //console.log("depth of coor for coor=", coor, " depth = ", determineDepth(coor, pos));

            if (determineDepth(coor, pos) > range) {
                keepPushing = false;
            }

           // console.log("coor = ", coor);
           // console.log("depth of coor", determineDepth(coor, pos));

            if (grid[coor[1]][coor[0]] === 1 && keepPushing) {
                output.push(coor);
           //     console.log("!!!! temp = ", temp);
            }

            if (coor[1] % 2 === 0) {

                //console.log("coor = ", coor);


                // up left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1] - 1]) && coor[0] - 1 >= 0 && coor[1] - 1 >= 0 && keepPushing ) {

                    frontier.push([coor[0] - 1, coor[1] - 1]);
                    visited.push([coor[0] - 1, coor[1] - 1]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }
                }

                // left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1]]) && coor[0] - 1 >= 0 && keepPushing) {

                    frontier.push([coor[0] - 1, coor[1]]);
                    visited.push([coor[0] - 1, coor[1]]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }
                }


                // down left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1] + 1]) && coor[0] - 1 >= 0 && coor[1] + 1 <= MAXHEIGHT && keepPushing) {

                    frontier.push([coor[0] - 1, coor[1] + 1]);
                    visited.push([coor[0] - 1, coor[1] + 1]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }
                }

                // down right
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] + 1]) && coor[1] + 1 <= MAXHEIGHT && keepPushing) {

                    frontier.push([coor[0], coor[1] + 1]);
                    visited.push([coor[0], coor[1] + 1]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }

                }

                // right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1]]) && coor[0] + 1 <= MAXWIDTH && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1]]);
                    visited.push([coor[0] + 1, coor[1]]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }

                }

                // up right
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] - 1]) && coor[1] - 1 >= 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] - 1]);
                    visited.push([coor[0], coor[1] - 1]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }

                }

            } else {  //odd rows

                //up left
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] - 1]) && coor[1] - 1 >= 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] - 1]);
                    visited.push([coor[0], coor[1] - 1]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }

                }

                // left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1]]) && coor[0] - 1 >= 0 && keepPushing) {

                    frontier.push([coor[0] - 1, coor[1]]);
                    visited.push([coor[0] - 1, coor[1]]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }

                }

                //down left
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] + 1]) && coor[1] + 1 <= MAXHEIGHT && keepPushing) {

                    frontier.push([coor[0], coor[1] + 1]);
                    visited.push([coor[0], coor[1] + 1]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }

                }

                //down right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1] + 1]) && coor[0] + 1 <= MAXWIDTH && coor[1] + 1 <= MAXHEIGHT && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1] + 1]);
                    visited.push([coor[0] + 1, coor[1] + 1]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }

                }

                //right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1]]) && coor[0] + 1 <= MAXWIDTH && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1]]);
                    visited.push([coor[0] + 1, coor[1]]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }

                }

                //up right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1] - 1]) && coor[0] + 1 <= MAXWIDTH && coor[1] - 1 >= 0 && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1] - 1]);
                    visited.push([coor[0] + 1, coor[1] - 1]);

                    // if (depth < range) {
                    //     elementsUntilDepthIncrease++;
                    // }


                }
            }

           // if (grid[coor[1]][coor[0]] === 1) {
             //   output.push(coor);
           // }
        }

        return output;
    }

    function determineAdjacentHeroes(pos) {

        let output = [];

        if (pos[1] % 2 === 0) {

            // up left
            if (pos[0] - 1 >= 0 && pos[1] - 1 >= 0) {
                if (grid[pos[1] - 1][pos[0] - 1] === 1) {
                    output.push([pos[0] - 1, pos[1] - 1]);
                }
            }

            // left
            if (pos[0] - 1 >= 0) {
                if (grid[pos[1]][pos[0] - 1] === 1) {
                    output.push([pos[0] - 1, pos[1]]);
                }
            }

            // down left
            if (pos[0] - 1 >= 0 && pos[1] + 1 <= MAXHEIGHT) {
                if (grid[pos[1] + 1][pos[0] - 1] === 1) {
                    output.push([pos[0] - 1, pos[1] + 1]);
                }
            }

            // down right
            if (pos[1] + 1 <= MAXHEIGHT) {
                if (grid[pos[1] + 1][pos[0]] === 1) {
                    output.push([pos[0], pos[1] + 1]);
                }
            }

            // right
            if (pos[0] + 1 <= MAXWIDTH) {
                if (grid[pos[1]][pos[0] + 1] === 1) {
                    output.push([pos[0] + 1, pos[1]]);
                }
            }

            // up right
            if (pos[1] - 1 >= 0) {
                if (grid[pos[1] - 1][pos[0]] === 1) {
                    output.push([pos[0], pos[1] - 1]);
                }
            }

        } else {    //odd rows

            // up left
            if (pos[1] - 1 >= 0) {
                if (grid[pos[1] - 1][pos[0]] === 1) {
                    output.push([pos[0], pos[1] - 1]);
                }
            }

            //left
            if (pos[0] - 1 >= 0) {
                if (grid[pos[1]][pos[0] - 1] === 1) {
                    output.push([pos[0] - 1, pos[1]]);
                }
            }

            //down left
            if (pos[1] + 1 <= MAXHEIGHT) {
                if (grid[pos[1] + 1][pos[0]] === 1) {
                    output.push([pos[0], pos[1] + 1]);
                }
            }

            //down right
            if (pos[0] + 1 <= MAXWIDTH && pos[1] + 1 <= MAXHEIGHT) {
                if (grid[pos[1] + 1][pos[0] + 1] === 1) {
                    output.push([pos[0] + 1, pos[1] + 1]);
                }
            }

            //right
            if (pos[0] + 1 <= MAXWIDTH) {
                if (grid[pos[1]][pos[0] + 1] === 1) {
                    output.push([pos[0] + 1, pos[1]]);
                }
            }

            //up right
            if (pos[1] - 1 >= 0 && pos[0] + 1 <= MAXWIDTH) {
                if (grid[pos[1] - 1][pos[0] + 1] === 1) {
                    output.push([pos[0] + 1, pos[1] - 1]);
                }
            }

        }


        return output;


    }

    function generateAvailableMoves(pos, range) {

        let output = [];
        let frontier = [];
        let visited = [pos];
        let coor;
        let keepPushing = true;

        cameFromGrid =     [[[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []]];

        //check if we're starting on an even row
        if (pos[1] % 2 === 0) {

            console.log("pos = ", pos);

            // up left

            if (pos[0] - 1 >= 0 && pos[1] - 1 >= 0 && grid[pos[1] - 1][pos[0] - 1] === 0) {
                frontier.push([pos[0] - 1, pos[1] - 1]);
                visited.push([pos[0] - 1, pos[1] - 1]);

                cameFromGrid[pos[1] - 1][pos[0] - 1] = pos;
            }

            // left

            if (pos[0] - 1 >= 0 && grid[pos[1]][pos[0] - 1] === 0) {
                frontier.push([pos[0] - 1, pos[1]]);
                visited.push([pos[0] - 1, pos[1]]);

                cameFromGrid[pos[1]][pos[0] - 1] = pos;
            }

            // down left
            if (pos[0] - 1 >= 0 && pos[1] + 1 <= MAXHEIGHT && grid[pos[1] + 1][pos[0] - 1] === 0) {
                frontier.push([pos[0] - 1, pos[1] + 1]);
                visited.push([pos[0] - 1, pos[1] + 1]);

                cameFromGrid[pos[1] + 1][pos[0] - 1] = pos;
            }

            // down right
            if (pos[1] + 1 <= MAXHEIGHT && grid[pos[1] + 1][pos[0]] === 0) {
                frontier.push([pos[0], pos[1] + 1]);
                visited.push([pos[0], pos[1] + 1]);

                cameFromGrid[pos[1] + 1][pos[0]] = pos;
            }

            // right
            if (pos[0] + 1 <= MAXWIDTH && grid[pos[1]][pos[0] + 1] === 0) {
                frontier.push([pos[0] + 1, pos[1]]);
                visited.push([pos[0] + 1, pos[1]]);

                cameFromGrid[pos[1]][pos[0] + 1] = pos;
            }

            // up right
            if (pos[1] - 1 >= 0 && grid[pos[1] - 1][pos[0]] === 0) {
                frontier.push([pos[0], pos[1] - 1]);
                visited.push([pos[0], pos[1] - 1]);

                cameFromGrid[pos[1] - 1][pos[0]] = pos;
            }

        // odd rows
        } else {

           // console.log("BOOOOOOOOM");

            //up left
            if (pos[1] - 1 >= 0 && grid[pos[1] - 1][pos[0]] === 0) {
                frontier.push([pos[0], pos[1] - 1]);
                visited.push([pos[0], pos[1] - 1]);

                cameFromGrid[pos[1] - 1][pos[0]] = pos;
              //  elementsUntilDepthIncrease++;
            }

            // left
            if (pos[0] - 1 >= 0 && grid[pos[1]][pos[0] - 1] === 0) {
                frontier.push([pos[0] - 1, pos[1]]);
                visited.push([pos[0] - 1, pos[1]]);

                cameFromGrid[pos[1]][pos[0] - 1] = pos;
             //   elementsUntilDepthIncrease++;
            }

            // down left
            if (pos[1] + 1 <= MAXHEIGHT && grid[pos[1] + 1][pos[0]] === 0) {
                frontier.push([pos[0], pos[1] + 1]);
                visited.push([pos[0], pos[1] + 1]);

                cameFromGrid[pos[1] + 1][pos[0]] = pos;
             //   elementsUntilDepthIncrease++;
            }

            // down right
            if (pos[0] + 1 <= MAXWIDTH && pos[1] + 1 <= MAXHEIGHT && grid[pos[1] + 1][pos[0] + 1] === 0) {
                frontier.push([pos[0] + 1, pos[1] + 1]);
                visited.push([pos[0] + 1, pos[1] + 1]);

                cameFromGrid[pos[1] + 1][pos[0] + 1] = pos;
             //   elementsUntilDepthIncrease++;

            }

            // right
            if (pos[0] + 1 <= MAXWIDTH && grid[pos[1]][pos[0] + 1] === 0) {
                frontier.push([pos[0] + 1, pos[1]]);
                visited.push([pos[0] + 1, pos[1]]);

                cameFromGrid[pos[1]][pos[0] + 1] = pos;
             //   elementsUntilDepthIncrease++;
            }

            // up right
            if (pos[0] + 1 <= MAXWIDTH && pos[1] - 1 >= 0 && grid[pos[1] - 1][pos[0] + 1] === 0) {
                frontier.push([pos[0] + 1, pos[1] - 1]);
                visited.push([pos[0] + 1, pos[1] - 1]);

                cameFromGrid[pos[1] - 1][pos[0] + 1] = pos;
               // elementsUntilDepthIncrease++;
            }
        }

        while (frontier.length !== 0) {

            coor = frontier.shift();
            keepPushing = true;

            if (determineDepth(coor, pos) > range) {
                keepPushing = false;
            }

            if (grid[coor[1]][coor[0]] === 0 && keepPushing) {
                output.push(coor);
            }

            if (coor[1] % 2 === 0) {

                // up left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1] - 1]) && coor[0] - 1 >= 0 && coor[1] - 1 >= 0 && grid[coor[1] - 1][coor[0] - 1] === 0 && keepPushing ) {

                    frontier.push([coor[0] - 1, coor[1] - 1]);
                    visited.push([coor[0] - 1, coor[1] - 1]);

                    cameFromGrid[coor[1] - 1][coor[0] - 1] = coor;
                }

                // left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1]]) && coor[0] - 1 >= 0 && grid[coor[1]][coor[0] - 1] === 0 && keepPushing) {

                    frontier.push([coor[0] - 1, coor[1]]);
                    visited.push([coor[0] - 1, coor[1]]);

                    cameFromGrid[coor[1]][coor[0] - 1] = coor;

                }


                // down left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1] + 1]) && coor[0] - 1 >= 0 && coor[1] + 1 <= MAXHEIGHT && grid[coor[1] + 1][coor[0] - 1] === 0 && keepPushing) {

                    frontier.push([coor[0] - 1, coor[1] + 1]);
                    visited.push([coor[0] - 1, coor[1] + 1]);

                    cameFromGrid[coor[1] + 1][coor[0] - 1] = coor;
                }

                // down right
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] + 1]) && coor[1] + 1 <= MAXHEIGHT && grid[coor[1] + 1][coor[0]] === 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] + 1]);
                    visited.push([coor[0], coor[1] + 1]);

                    cameFromGrid[coor[1] + 1][coor[0]] = coor;

                }

                // right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1]]) && coor[0] + 1 <= MAXWIDTH && grid[coor[1]][coor[0] + 1] === 0 && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1]]);
                    visited.push([coor[0] + 1, coor[1]]);

                    cameFromGrid[coor[1]][coor[0] + 1] = coor;

                }

                // up right
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] - 1]) && coor[1] - 1 >= 0 && grid[coor[1] - 1][coor[0]] === 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] - 1]);
                    visited.push([coor[0], coor[1] - 1]);

                    cameFromGrid[coor[1] - 1][coor[0]] = coor;
                }

            } else {  //odd rows

                //up left
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] - 1]) && coor[1] - 1 >= 0 && grid[coor[1] - 1][coor[0]] === 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] - 1]);
                    visited.push([coor[0], coor[1] - 1]);

                    cameFromGrid[coor[1] - 1][coor[0]] = coor;
                }

                // left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1]]) && coor[0] - 1 >= 0 && grid[coor[1]][coor[0] - 1] === 0 && keepPushing) {

                    frontier.push([coor[0] - 1, coor[1]]);
                    visited.push([coor[0] - 1, coor[1]]);

                    cameFromGrid[coor[1]][coor[0] - 1] = coor;
                }

                //down left
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] + 1]) && coor[1] + 1 <= MAXHEIGHT && grid[coor[1] + 1][coor[0]] === 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] + 1]);
                    visited.push([coor[0], coor[1] + 1]);

                    cameFromGrid[coor[1] + 1][coor[0]] = coor;
                }

                //down right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1] + 1]) && coor[0] + 1 <= MAXWIDTH && coor[1] + 1 <= MAXHEIGHT && grid[coor[1] + 1][coor[0] + 1] === 0 && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1] + 1]);
                    visited.push([coor[0] + 1, coor[1] + 1]);

                    cameFromGrid[coor[1] + 1][coor[0] + 1] = coor;

                }

                //right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1]]) && coor[0] + 1 <= MAXWIDTH && grid[coor[1]][coor[0] + 1] === 0 && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1]]);
                    visited.push([coor[0] + 1, coor[1]]);

                    cameFromGrid[coor[1]][coor[0] + 1] = coor;

                }

                //up right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1] - 1]) && coor[0] + 1 <= MAXWIDTH && coor[1] - 1 >= 0 && grid[coor[1] - 1][coor[0] + 1] === 0 && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1] - 1]);
                    visited.push([coor[0] + 1, coor[1] - 1]);

                    cameFromGrid[coor[1] - 1][coor[0] + 1] = coor;
                }
            }

        }

        let path;

        for (let i = output.length - 1; i >= 0; i--) {
            path = determinePath(output[i], heroArray[heroIndex].coor);

            if (path.length > range) {
                output.splice(i, 1);
            }
        }

        return output;
    }

    function createCameFromGrid(pos) {

        let output = [];
        let frontier = [];
        let visited = [pos];
        let coor;
        let keepPushing = true;

        cameFromGrid =     [[[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []],
                            [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []]];

        //check if we're starting on an even row
        if (pos[1] % 2 === 0) {

            console.log("pos = ", pos);

            // up left

            if (pos[0] - 1 >= 0 && pos[1] - 1 >= 0 && grid[pos[1] - 1][pos[0] - 1] === 0) {
                frontier.push([pos[0] - 1, pos[1] - 1]);
                visited.push([pos[0] - 1, pos[1] - 1]);

                cameFromGrid[pos[1] - 1][pos[0] - 1] = pos;
            }

            // left

            if (pos[0] - 1 >= 0 && grid[pos[1]][pos[0] - 1] === 0) {
                frontier.push([pos[0] - 1, pos[1]]);
                visited.push([pos[0] - 1, pos[1]]);

                cameFromGrid[pos[1]][pos[0] - 1] = pos;
            }

            // down left
            if (pos[0] - 1 >= 0 && pos[1] + 1 <= MAXHEIGHT && grid[pos[1] + 1][pos[0] - 1] === 0) {
                frontier.push([pos[0] - 1, pos[1] + 1]);
                visited.push([pos[0] - 1, pos[1] + 1]);

                cameFromGrid[pos[1] + 1][pos[0] - 1] = pos;
            }

            // down right
            if (pos[1] + 1 <= MAXHEIGHT && grid[pos[1] + 1][pos[0]] === 0) {
                frontier.push([pos[0], pos[1] + 1]);
                visited.push([pos[0], pos[1] + 1]);

                cameFromGrid[pos[1] + 1][pos[0]] = pos;
            }

            // right
            if (pos[0] + 1 <= MAXWIDTH && grid[pos[1]][pos[0] + 1] === 0) {
                frontier.push([pos[0] + 1, pos[1]]);
                visited.push([pos[0] + 1, pos[1]]);

                cameFromGrid[pos[1]][pos[0] + 1] = pos;
            }

            // up right
            if (pos[1] - 1 >= 0 && grid[pos[1] - 1][pos[0]] === 0) {
                frontier.push([pos[0], pos[1] - 1]);
                visited.push([pos[0], pos[1] - 1]);

                cameFromGrid[pos[1] - 1][pos[0]] = pos;
            }

        // odd rows
        } else {

           // console.log("BOOOOOOOOM");

            //up left
            if (pos[1] - 1 >= 0 && grid[pos[1] - 1][pos[0]] === 0) {
                frontier.push([pos[0], pos[1] - 1]);
                visited.push([pos[0], pos[1] - 1]);

                cameFromGrid[pos[1] - 1][pos[0]] = pos;
              //  elementsUntilDepthIncrease++;
            }

            // left
            if (pos[0] - 1 >= 0 && grid[pos[1]][pos[0] - 1] === 0) {
                frontier.push([pos[0] - 1, pos[1]]);
                visited.push([pos[0] - 1, pos[1]]);

                cameFromGrid[pos[1]][pos[0] - 1] = pos;
             //   elementsUntilDepthIncrease++;
            }

            // down left
            if (pos[1] + 1 <= MAXHEIGHT && grid[pos[1] + 1][pos[0]] === 0) {
                frontier.push([pos[0], pos[1] + 1]);
                visited.push([pos[0], pos[1] + 1]);

                cameFromGrid[pos[1] + 1][pos[0]] = pos;
             //   elementsUntilDepthIncrease++;
            }

            // down right
            if (pos[0] + 1 <= MAXWIDTH && pos[1] + 1 <= MAXHEIGHT && grid[pos[1] + 1][pos[0] + 1] === 0) {
                frontier.push([pos[0] + 1, pos[1] + 1]);
                visited.push([pos[0] + 1, pos[1] + 1]);

                cameFromGrid[pos[1] + 1][pos[0] + 1] = pos;
             //   elementsUntilDepthIncrease++;

            }

            // right
            if (pos[0] + 1 <= MAXWIDTH && grid[pos[1]][pos[0] + 1] === 0) {
                frontier.push([pos[0] + 1, pos[1]]);
                visited.push([pos[0] + 1, pos[1]]);

                cameFromGrid[pos[1]][pos[0] + 1] = pos;
             //   elementsUntilDepthIncrease++;
            }

            // up right
            if (pos[0] + 1 <= MAXWIDTH && pos[1] - 1 >= 0 && grid[pos[1] - 1][pos[0] + 1] === 0) {
                frontier.push([pos[0] + 1, pos[1] - 1]);
                visited.push([pos[0] + 1, pos[1] - 1]);

                cameFromGrid[pos[1] - 1][pos[0] + 1] = pos;
               // elementsUntilDepthIncrease++;
            }
        }

        while (frontier.length !== 0) {

            coor = frontier.shift();
           // keepPushing = true;

            // if (determineDepth(coor, pos) > range) {
            //     keepPushing = false;
            // }

            // if (grid[coor[1]][coor[0]] === 0 && keepPushing) {
            //     output.push(coor);
            // }

            if (coor[1] % 2 === 0) {

                // up left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1] - 1]) && coor[0] - 1 >= 0 && coor[1] - 1 >= 0 && grid[coor[1] - 1][coor[0] - 1] === 0 && keepPushing ) {

                    frontier.push([coor[0] - 1, coor[1] - 1]);
                    visited.push([coor[0] - 1, coor[1] - 1]);

                    cameFromGrid[coor[1] - 1][coor[0] - 1] = coor;
                }

                // left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1]]) && coor[0] - 1 >= 0 && grid[coor[1]][coor[0] - 1] === 0 && keepPushing) {

                    frontier.push([coor[0] - 1, coor[1]]);
                    visited.push([coor[0] - 1, coor[1]]);

                    cameFromGrid[coor[1]][coor[0] - 1] = coor;

                }


                // down left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1] + 1]) && coor[0] - 1 >= 0 && coor[1] + 1 <= MAXHEIGHT && grid[coor[1] + 1][coor[0] - 1] === 0 && keepPushing) {

                    frontier.push([coor[0] - 1, coor[1] + 1]);
                    visited.push([coor[0] - 1, coor[1] + 1]);

                    cameFromGrid[coor[1] + 1][coor[0] - 1] = coor;
                }

                // down right
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] + 1]) && coor[1] + 1 <= MAXHEIGHT && grid[coor[1] + 1][coor[0]] === 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] + 1]);
                    visited.push([coor[0], coor[1] + 1]);

                    cameFromGrid[coor[1] + 1][coor[0]] = coor;

                }

                // right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1]]) && coor[0] + 1 <= MAXWIDTH && grid[coor[1]][coor[0] + 1] === 0 && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1]]);
                    visited.push([coor[0] + 1, coor[1]]);

                    cameFromGrid[coor[1]][coor[0] + 1] = coor;

                }

                // up right
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] - 1]) && coor[1] - 1 >= 0 && grid[coor[1] - 1][coor[0]] === 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] - 1]);
                    visited.push([coor[0], coor[1] - 1]);

                    cameFromGrid[coor[1] - 1][coor[0]] = coor;
                }

            } else {  //odd rows

                //up left
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] - 1]) && coor[1] - 1 >= 0 && grid[coor[1] - 1][coor[0]] === 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] - 1]);
                    visited.push([coor[0], coor[1] - 1]);

                    cameFromGrid[coor[1] - 1][coor[0]] = coor;
                }

                // left
                if (!arrayIncludesCoordinates(visited, [coor[0] - 1, coor[1]]) && coor[0] - 1 >= 0 && grid[coor[1]][coor[0] - 1] === 0 && keepPushing) {

                    frontier.push([coor[0] - 1, coor[1]]);
                    visited.push([coor[0] - 1, coor[1]]);

                    cameFromGrid[coor[1]][coor[0] - 1] = coor;
                }

                //down left
                if (!arrayIncludesCoordinates(visited, [coor[0], coor[1] + 1]) && coor[1] + 1 <= MAXHEIGHT && grid[coor[1] + 1][coor[0]] === 0 && keepPushing) {

                    frontier.push([coor[0], coor[1] + 1]);
                    visited.push([coor[0], coor[1] + 1]);

                    cameFromGrid[coor[1] + 1][coor[0]] = coor;
                }

                //down right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1] + 1]) && coor[0] + 1 <= MAXWIDTH && coor[1] + 1 <= MAXHEIGHT && grid[coor[1] + 1][coor[0] + 1] === 0 && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1] + 1]);
                    visited.push([coor[0] + 1, coor[1] + 1]);

                    cameFromGrid[coor[1] + 1][coor[0] + 1] = coor;

                }

                //right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1]]) && coor[0] + 1 <= MAXWIDTH && grid[coor[1]][coor[0] + 1] === 0 && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1]]);
                    visited.push([coor[0] + 1, coor[1]]);

                    cameFromGrid[coor[1]][coor[0] + 1] = coor;

                }

                //up right
                if (!arrayIncludesCoordinates(visited, [coor[0] + 1, coor[1] - 1]) && coor[0] + 1 <= MAXWIDTH && coor[1] - 1 >= 0 && grid[coor[1] - 1][coor[0] + 1] === 0 && keepPushing) {

                    frontier.push([coor[0] + 1, coor[1] - 1]);
                    visited.push([coor[0] + 1, coor[1] - 1]);

                    cameFromGrid[coor[1] - 1][coor[0] + 1] = coor;
                }
            }

        }

        return;
    }

    function determineDepth(coord, enemyPos) {

            let coordInCube = oddr_to_cube(coord);
            let posInCube = oddr_to_cube(enemyPos);

            let output = cube_distance(coordInCube, posInCube);

//            console.log("coordInCube = ", coordInCube, "Pos in cube = ", posInCube);

            function cube_distance(a, b) {
                return (Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]) + Math.abs(a[2] - b[2])) / 2
            }

            function oddr_to_cube(hex) {
                var x = hex[0] - (hex[1] - (hex[1]&1)) / 2;
                var z = hex[1];
                var y = -x-z;
                return [x, y, z];
            }

            return output;

    }



    function adjustUnitPos () {
        player.x = testCoor[0];
        player.y = testCoor[1] - 15;
    }

    // function enemyRangedAttack(heroPos, enemyPos) {

    //    // this.add.image(enemyPos[0] - 5, enemyPos[1] - 5, 'spark');
    //    // spark.setVelocityX(200);

    //    //console.log("GGGGG got here");

    //     let bulletCoor = calculateCoordinates(enemyPos);

    //     bullet.setActive(true);
    //     bullet.setVisible(true);
    //     bullet.x = bulletCoor[0] - 5;
    //     bullet.y = bulletCoor[1] - 5;

    //     let x;
    //     let y;

    //     let heroCoor = calculateCoordinates(heroPos);
    //     let enemyCoor = calculateCoordinates(enemyPos);

    //     let angle = Phaser.Math.Angle.Between(heroCoor[0], heroCoor[1], enemyCoor[0], enemyCoor[1]);

    //     x = Math.cos(angle) * 200;
    //     y = Math.sin(angle) * 200;

    //     bullet.setVelocityX(-x);
    //     bullet.setVelocityY(-y);
    //     // bullet.setAccelerationY(100);


    //     //game.physics.arcade.moveToXY(bullet, player.x, player.y, 0, 3000);

    //     enemyBulletMoving = true;

    //     if (x > 0) {
    //         enemyBulletMovingLeft = true;
    //     } else if (x < 0) {
    //         enemyBulletMovingRight = true;
    //     }

    //     if (y > 0) {
    //         enemyBulletMovingUp = true;
    //     } else if (y < 0) {
    //         enemyBulletMovingDown = true;
    //     }

    //     enemyBulletMovingTo = heroPos;
    // }

    // function anEnemyHasDied() {

    //     let output = [];

    //     let enemySprite;



    // }

    function enemyDies(enemySprite) {

        enemySprite.anims.play('barbDead');
        console.log("got to this part");
        enemySprite.isDead = true;

    }

    function enemyFinishedDying(sprite) {
        doEnemyMoves();
    }

    function doEnemyMoves() {

        let adjacentHeroCoors;


        if (enemyDying && !enemy.isDead) {

            enemyDies(enemy);
            return;

        }

        if (enemyBDying && !enemyB.isDead) {

            enemyDies(enemyB);
            return;
        }

        if (enemyCDying && !enemyC.isDead) {

            enemyDies(enemyC);
            return;
        }


        console.log("Indo enemey  moevs.  enemyIndex = ", enemyIndex);
        console.log("Indo enemy mooevs.  enemyArray.length - 1 = ", enemyArray.length - 1);

                              //  for (let i = 0; i < enemyArray.length; i++) {
        if (enemyIndex > enemyArray.length - 1) {

            console.log("abcd");

            playersTurn = true;
            return;
        }

        console.log("efgh");

        if (!enemyArray[enemyIndex].isDead) {

            console.log("###At this point ,enemy index = ", enemyIndex);


            console.log("enemyArray[enemyIndex].coor =  ", enemyArray[enemyIndex].coor);
            adjacentHeroCoors = determineAdjacentHeroes(enemyArray[enemyIndex].coor);
            if (adjacentHeroCoors.length === 0) {


                let closestHeroIndex = pickClosestHeroToMoveToward(enemyArray[enemyIndex]);

                console.log("closestHeroIndex = ", closestHeroIndex);

                let targetHex = pickHexAdjacentHerotoMoveTo(heroArray[closestHeroIndex].coor, enemyArray[enemyIndex].coor);

                if (targetHex.length > 0) {

                    console.log("targetHex = ", targetHex);

                    let enemyRange = 4;

                   // let tempMoves = generateAvailableMoves(enemyArray[enemyIndex].coor, enemyRange);

                    //console.log("")

                    //let tempPath = determinePath(targetHex, enemyArray[enemyIndex].coor);

                   // let distanceToTarget = determineDepth(targetHex, enemyArray[enemyIndex].coor);

                    //console.log("tempPath = ", tempPath);

                    //let distanceToTarget = tempPath.length;

                    console.log("TTTTAt this point ,enemy index = ", enemyIndex);

                    createCameFromGrid(enemyArray[enemyIndex].coor);


                    let tempPath = determinePath(targetHex, enemyArray[enemyIndex].coor);

                    let distanceToTarget = tempPath.length;

                    console.log("Distance to target = ", distanceToTarget);

                    if (enemyRange < distanceToTarget) {

                        let enemyAvailableMoves = generateAvailableMoves(enemyArray[enemyIndex].coor, enemyRange);


                                                                //let closerTargerHex = pickHexClosestToTarget(enemyRange, targetHex);

                        let currentClosest = 100;
                        let choiceIndex;

                        for (let i = 0; i < enemyAvailableMoves.length; i++) {

                            let currentHexDistance = determineDepth(targetHex, enemyAvailableMoves[i]);
                            if (currentHexDistance <= currentClosest) {
                                currentClosest = currentHexDistance;
                                choiceIndex = i;
                            }
                        }

                        let closerTargetHex = enemyAvailableMoves[choiceIndex];

                        //console.log("closerTargetHex = ", closerTargetHex);

                        let enemyHexPath = determinePath(closerTargetHex, enemyArray[enemyIndex].coor);

                        enemyMoveToNextHex(enemyArray[enemyIndex], enemyHexPath, enemyArray[enemyIndex].coor);

                        //console.log("enemeyHexPath at end = ", enemyHexPath)

                        enemyArray[enemyIndex].coor = enemyHexPath[enemyHexPath.length - 1];



                    }  else {  // target hex is within range of enemy move points

                        let enemyAvailableMoves = generateAvailableMoves(enemyArray[enemyIndex].coor, enemyRange);
                        let enemyHexPath = determinePath(targetHex, enemyArray[enemyIndex].coor);

                        console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                        console.log("enemyHex Path for enemyindex = ", enemyIndex, "enemyHexPath = ", enemyHexPath);

                        enemyArray[enemyIndex].attackingThisTurn = true;

                        let newAdjacentHeroCoors = determineAdjacentHeroes(enemyHexPath[enemyHexPath.length - 1]);

                        console.log("newadjacentHeroCoors = ", newAdjacentHeroCoors);
                        console.log("newadjacentHeroCoors[0] = ", newAdjacentHeroCoors[0]);

                        enemyArray[enemyIndex].indexOfHeroToBeAttacked = determineWhichHero(newAdjacentHeroCoors[0]);

                        enemyMoveToNextHex(enemyArray[enemyIndex], enemyHexPath, enemyArray[enemyIndex].coor);

                        console.log("!!!enemeyHexPath at end = ", enemyHexPath)
                        enemyArray[enemyIndex].coor = enemyHexPath[enemyHexPath.length - 1];
                    }
                }


            } else { // there are nearby heroes

                let currentHeroIndex = determineWhichHero(adjacentHeroCoors[0]);

                console.log("In do enemy moves.  EnemyIndex = ", enemyIndex);

                console.log("Calling enemyattack hero from doenemymoves");

                enemyAttackHero(heroArray[currentHeroIndex], enemyArray[enemyIndex]);

            }

        } else {//enemy is dead
            enemyIndex++;
            console.log("peppermint");
            doEnemyMoves();
        }


    }

    function pickClosestHeroToMoveToward(enemyMoving) {

        let output;
        let currentClosest = 0;
        let closestDepth = 100;
        let currentDepth;

        for (let i = 0; i < heroArray.length; i++) {

            //console.log("i = ", i);
            //console.log("heroArray.length = ", heroArray.length);

            //console.log("!!!!!!!!!!! enemyMoving.coor =", enemyMoving.coor, "heroArray[i].coor =", heroArray[i].coor);

            currentDepth = determineDepth(enemyMoving.coor, heroArray[i].coor);

            //console.log("depth of currentDepth =" , currentDepth);

            if (currentDepth < closestDepth) {
                currentClosest = i;
                closestDepth = currentDepth;
            }
        }

        return currentClosest;
    }

    function stupid() {

    }


    function enemyAttackHero(hero, enemySprite) {

        //let currentHeroIndex = determineWhichHero(heroAtCoor);


        if (hero.x < enemySprite.x) {
            enemySprite.anims.play('barbAttackLeft');
        } else {
            enemySprite.anims.play('barbAttack');
        }

        console.log("In enemyAttack hero function.  enemyIndex = ", enemyIndex);

        enemyArray[enemyIndex].once('animationcomplete', attackComplete);
    }

    function pickHexAdjacentHerotoMoveTo(heroPos, enemyPos) {

        let hexUpLeft;
        let hexLeft;
        let hexDownLeft;
        let hexDownRight;
        let hexRight;
        let hexUpRight;

        if (heroPos[1] % 2 === 0) {  //even rows

            if (heroPos[0] - 1 >= 0 && heroPos[1] - 1 >= 0 && grid[heroPos[1] - 1][heroPos[0] - 1] === 0) {
                hexUpLeft = [heroPos[0] - 1, heroPos[1] - 1];
            }
            if (heroPos[0] - 1 >= 0 && grid[heroPos[1]][heroPos[0] - 1] === 0) {
                hexLeft = [heroPos[0] - 1, heroPos[1]];
            }
            if (heroPos[0] - 1 >= 0 && heroPos[1] + 1 <= MAXHEIGHT && grid[heroPos[1] + 1][heroPos[0] - 1] === 0) {
                hexDownLeft = [heroPos[0] - 1, heroPos[1] + 1];
            }
            if (heroPos[1] + 1 <= MAXHEIGHT && grid[heroPos[1] + 1][heroPos[0]] === 0) {
                hexDownRight = [heroPos[0], heroPos[1] + 1];
            }
            if (heroPos[0] + 1 <= MAXWIDTH && grid[heroPos[1]][heroPos[0] + 1] === 0) {
                hexRight = [heroPos[0] + 1, heroPos[1]];
            }
            if (heroPos[1] - 1 >= 0 && grid[heroPos[1] - 1][heroPos[0]] === 0) {
                hexUpRight = [heroPos[0], heroPos[1] - 1];
            }

        } else {  //odd rows

            if (heroPos[1] - 1 >= 0 && grid[heroPos[1] - 1][heroPos[0]] === 0) {
                hexUpLeft = [heroPos[0], heroPos[1] - 1];
            }
            if (heroPos[0] - 1 >= 0 && grid[heroPos[1]][heroPos[0] - 1] === 0) {
                hexLeft = [heroPos[0] - 1, heroPos[1]];
            }
            if (heroPos[1] + 1 <= MAXHEIGHT && grid[heroPos[1] + 1][heroPos[0]] === 0) {
                hexDownLeft = [heroPos[0], heroPos[1] + 1];
            }
            if (heroPos[0] + 1 <= MAXWIDTH && heroPos[1] + 1 <= MAXHEIGHT && grid[heroPos[1] + 1][heroPos[0] + 1] === 0) {
                hexDownRight = [heroPos[0] + 1, heroPos[1] + 1];
            }
            if (heroPos[0] + 1 <= MAXWIDTH && grid[heroPos[1]][heroPos[0] + 1] === 0) {
                hexRight = [heroPos[0] + 1, heroPos[1]];
            }
            if (heroPos[0] + 1 <= MAXWIDTH && heroPos[1] - 1 >= 0 && grid[heroPos[1] - 1][heroPos[0] + 1] === 0) {
                hexUpRight = [heroPos[0] + 1, heroPos[1] - 1];
            }

        }

                                // let distanceHexUpLeft = determineDepth(hexUpLeft, enemyPos);
                                // let distanceHexLeft = determineDepth(hexLeft, enemyPos);
                                // let distanceHexDownLeft = determineDepth(hexDownLeft, enemyPos);
                                // let distanceHexDownRight = determineDepth(hexDownRight, enemyPos);
                                // let distanceHexRight = determineDepth(hexRight, enemyPos);
                                // let distanceHexUpRight = determineDepth(hexUpRight, enemyPos);

                                //console.log("distance hex up left =", determineDepth(hexUpLeft, enemyPos));
                                //console.log("distance hex left =", determineDepth(hexLeft, enemyPos));
                                // console.log("distance hex down left =", distanceHexDownLeft);
                                // console.log("distance hex down right =", distanceHexDownRight);
                                // console.log("distance hex right =", distanceHexRight);
                                // console.log("distance hex up right =", distanceHexUpRight);

        let arrayOfDistances = [];

        if (hexUpLeft) {
            arrayOfDistances.push(hexUpLeft);
        }
        if (hexLeft) {
            arrayOfDistances.push(hexLeft);
        }
        if (hexDownLeft) {
            arrayOfDistances.push(hexDownLeft);
        }
        if (hexDownRight) {
            arrayOfDistances.push(hexDownRight);
        }
        if (hexRight) {
            arrayOfDistances.push(hexRight);
        }
        if (hexUpRight) {
            arrayOfDistances.push(hexUpRight);
        }

        if (arrayOfDistances.length > 0) {

            let shortestDistance = determineDepth(arrayOfDistances[0], enemyPos);
            let closestIndex = 0;

            for (let i = 0; i < arrayOfDistances.length; i++) {

                console.log("depth for array of distances of ", i, " =", determineDepth(arrayOfDistances[i], enemyPos));
                console.log("hex of i =", arrayOfDistances[i]);

                if (determineDepth(arrayOfDistances[i], enemyPos) < shortestDistance) {
                    shortestDistance = determineDepth(arrayOfDistances[i], enemyPos);
                    closestIndex = i;
                }
            }

            //console.log("shortestDistance = ", shortestDistance);
            //console.log("hex chosen = ", arrayOfDistances[closestIndex]);

            return arrayOfDistances[closestIndex];

        } else {
            return [];
        }
    }

    function enemyMoveToNextHex(enemySprite, path, pos) {

        let index = 0;

        console.log("path = ", path);

        let currentEnemyCoor = calculateCoordinates(path[0]);
        let enemyTween;
                               // let currentIndex = 0;

        console.log("AAAA made it here");

        if (enemySprite.x > currentEnemyCoor[0]) {

            console.log("BBBB");
            enemySprite.anims.play('barbWalkLeft');
        } else {

            console.log("CCCC");
            enemySprite.anims.play('barbWalk');
        }

        console.log("Calling submovetonext hex from enemymovetonexthex");

        subMoveToNextHex();

        function subMoveToNextHex() {

            index++;

            console.log("This is right before playertween begins.");

            playerTween = selfScene.tweens.add({
                targets: enemySprite,
                x: currentEnemyCoor[0] - 2,
                y: currentEnemyCoor[1] - 14,
                duration: 400,
                onComplete: function() {

                console.log("Got over heeeeeereeeee");

                    if (index < path.length) {

                        console.log("path[index] = ", path[index]);

                        currentEnemyCoor = calculateCoordinates(path[index]);

                        if (enemySprite.x > currentEnemyCoor[0]) {
                            enemySprite.anims.play('barbWalkLeft');
                        } else {
                            enemySprite.anims.play('barbWalk');
                        }

                        console.log("Calling submovetonext hex from submovetonexthex");

                        subMoveToNextHex();

                    } else { // finished path




                        enemySprite.anims.play('barbSnooze');

                        grid[pos[1]][pos[0]] = 0;
                        let tempCoor = path[path.length - 1];
                        grid[tempCoor[1]][tempCoor[0]] = 2;



                        if (enemySprite.attackingThisTurn){

                            console.log("enemysprite.indexofherotobeattacked = ", enemySprite.indexOfHeroToBeAttacked);
                            console.log("enemy sprite hit points = ", enemySprite.hitPoints);

                            console.log("Calling enemyAttackhero from  enemymovetonexthex");

                            enemyAttackHero(heroArray[enemySprite.indexOfHeroToBeAttacked], enemySprite);
                        } else {

                            enemyIndex++;

                            if (enemyIndex < enemyArray.length) {

                            //  console.log("enemyIndex = ", enemyIndex);
                            //  console.log("enemyArray.lenght = ", enemyArray.length);

                            console.log("Calling doenemymoves from enemymovetonexthex");
                                doEnemyMoves();
                            } else {
                                enemyIndex = 0;
                                playersTurn = true;

                              //  enemyArray[enemyIndex].on('animationcomplete', stupid);

                            }
                        }
                    }
                }
            });
        }
    }

    function determineAdjacentEnemies(heroPos) {

        let output = [];

        if (heroPos[1] % 2 === 0) {  //even rows

            if (heroPos[0] - 1 >= 0 && heroPos[1] - 1 >= 0) {
                if (grid[heroPos[1] - 1][heroPos[0] - 1] === 2) {
                    output.push([heroPos[0] - 1, heroPos[1] - 1]);
                }
            }
            if (heroPos[0] - 1 >= 0) {
                if (grid[heroPos[1]][heroPos[0] - 1] === 2) {
                    output.push([heroPos[0] - 1, heroPos[1]]);
                }
            }
            if (heroPos[0] - 1 >= 0 && heroPos[1] + 1 <= MAXHEIGHT) {
                if (grid[heroPos[1] + 1][heroPos[0] - 1] === 2) {
                    output.push([heroPos[0] - 1, heroPos[1] + 1]);
                }
            }
            if (heroPos[1] + 1 <= MAXHEIGHT) {
                if (grid[heroPos[1] + 1][heroPos[0]] === 2) {
                    output.push([heroPos[0], heroPos[1] + 1]);
                }
            }
            if (heroPos[0] + 1 <= MAXWIDTH) {
                if (grid[heroPos[1]][heroPos[0] + 1] === 2) {
                    output.push([heroPos[0] + 1, heroPos[1]]);
                }
            }
            if (heroPos[1] - 1 >= 0) {
                if (grid[heroPos[1] - 1][heroPos[0]] === 2) {
                    output.push([heroPos[0], heroPos[1] - 1]);
                }
            }

        } else {  //odd rows

            if (heroPos[1] - 1 >= 0) {
                if (grid[heroPos[1] - 1][heroPos[0]] === 2) {
                    output.push([heroPos[0], heroPos[1] - 1]);
                }
            }
            if (heroPos[0] - 1 >= 0) {
                if (grid[heroPos[1]][heroPos[0] - 1] === 2) {
                    output.push([heroPos[0] - 1, heroPos[1]]);
                }
            }
            if (heroPos[1] + 1 <= MAXHEIGHT) {
                if (grid[heroPos[1] + 1][heroPos[0]] === 2) {
                    output.push([heroPos[0], heroPos[1] + 1]);
                }
            }
            if (heroPos[0] + 1 <= MAXWIDTH && heroPos[1] + 1 <= MAXHEIGHT) {
                if (grid[heroPos[1] + 1][heroPos[0] + 1] === 2) {
                    output.push([heroPos[0] + 1, heroPos[1] + 1]);
                }
            }
            if (heroPos[0] + 1 <= MAXWIDTH) {
                if (grid[heroPos[1]][heroPos[0] + 1] === 2) {
                    output.push([heroPos[0] + 1, heroPos[1]]);
                }
            }
            if (heroPos[0] + 1 <= MAXWIDTH && heroPos[1] - 1 >= 0) {
                if (grid[heroPos[1] - 1][heroPos[0] + 1] === 2) {
                    output.push([heroPos[0] + 1, heroPos[1] - 1]);
                }
            }
        }
        return output;
    }

</script>

</body>
</html>